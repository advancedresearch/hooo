
sym nat;
sym s;
sym z;

use type;

use cong;

fn nat_ty : true -> (nat' : type'(z')) {
    axiom nat_ty : true -> (nat' : type'(z'));
    x : true;
    let r = nat_ty(x) : (nat' : type'(z'));
    return r;
}

fn nat_zero_ty : true -> (z' : nat') {
    axiom nat_zero_ty : true -> (z' : nat');

    x : true;

    let r = nat_zero_ty(x) : (z' : nat');
    return r;
}

fn nat_refl : (x : nat') -> (x == x) {
    use eq_refl;
    use triv;

    let r = triv(eq_refl) : x == x;
    return r;
}

fn nat_symmetry : (x : nat') & (y : nat') & (x == y) -> (y == x) {
    use eq_symmetry;

    x : x == y;

    let r = eq_symmetry(x) : y == x;
    return r;
}

fn nat_transitivity :
    (x : nat') & (y : nat') & (z : nat') &
    (x == y) & (y == z)
-> (x == z) {
    use eq_transitivity;

    x : x == y;
    x2 : y == z;

    let r = eq_transitivity(x, x2) : x == z;
    return r;
}

fn nat_closed : (x : nat') & (x == y) -> (y : nat') {
    use ty_eq_left;
    use eq_to_right;

    x : (x : nat');
    x2 : x == y;

    let y = ty_eq_left(x2) : (x : nat') == (y : nat');
    let r = eq_to_right(y, x) : (y : nat');
    return r;
}

fn nat_succ_ty : (x : nat') -> (s'(x) : nat') {
    axiom nat_succ_ty : (x : nat') -> (s'(x) : nat');

    x : (x : nat');

    let r = nat_succ_ty(x) : (s'(x) : nat');
    return r;
}

fn nat_injection :
    (x : nat') & (y : nat') & (s'(x) == s'(y))
-> (x == y) {
    axiom nat_injection : (x : nat') & (y : nat') & (s'(x) == s'(y)) -> (x == y);

    x : (x : nat');
    x2 : (y : nat');
    x3 : s'(x) == s'(y);

    let r = nat_injection(x, x2, x3) : x == y;
    return r;
}

fn nat_contra : (x : nat') & (s'(x) == z') -> false {
    axiom nat_contra : (x : nat') & (s'(x) == z') -> false;

    x : (x : nat');
    x2 : s'(x) == z';

    let r = nat_contra(x, x2) : false;
    return r;
}

fn nat_induction :
    cong'(f) & f(z') & sym(f, all((x : nat') => (f'(x) => f'(s'(x)))))(f)
-> (x : nat') => f(x) {
    axiom nat_induction :
        cong'(f) & f(z') & sym(f, all((x : nat') => (f'(x) => f'(s'(x)))))(f)
        -> (x : nat') => f(x);

    x : cong'(f);
    x2 : f(z');
    x3 : sym(f, all((x : nat') => (f'(x) => f'(s'(x)))))(f);

    let r = nat_induction(x, x2, x3) : (x : nat') => f(x);
    return r;
}
