use mul;
use cong;

fn nat_mul_subst : mul'(a, b) & (a == c) & (b == d) -> mul'(c, d) {
    use nat_mul_cong;
    use cong_app_eq;
    use triv;
    use eq_to_right;
    use eq_transitivity;
    use cong_fun_eq;
    use cong_app;

    x : mul'(a, b);
    x2 : a == c;
    x3 : b == d;

    let y = triv(nat_mul_cong) : cong'(mul');
    let y2 = cong_app_eq(y, x2) : mul'(a) == mul'(c);
    let y3 = cong_app(y) : cong'(mul'(a));
    let y4 = cong_app(y) : cong'(mul'(c));
    let y5 = cong_fun_eq(y3, y4, y2) : mul'(a, b) == mul'(c, b);
    let y6 = cong_app_eq(y4, x3) : mul'(c, b) == mul'(c, d);
    let y7 = eq_transitivity(y5, y6) : mul'(a, b) == mul'(c, d);
    let r = eq_to_right(y7, x) : mul'(c, d);
    return r;
}

fn nat_mul_eq : (a == c) & (b == d) -> mul'(a, b) == mul'(c, d) {
    use refl;
    use nat_mul_subst;

    y1 : a == c;
    y2 : b == d;

    lam f : mul'(a, b) => mul'(c, d) {
        x : mul'(a, b);

        let r = nat_mul_subst(x, y1, y2) : mul'(c, d);
        return r;
    }
    lam g : mul'(c, d) => mul'(a, b) {
        use eq_symmetry;

        x : mul'(c, d);

        let x2 = eq_symmetry(y1) : c == a;
        let x3 = eq_symmetry(y2) : d == b;
        let r = nat_mul_subst(x, x2, x3) : mul'(a, b);
        return r;
    }
    let r = refl(f, g) : mul'(a, b) == mul'(c, d);
    return r;
}

fn nat_mul_eq_left : (a == b) -> mul'(a, c) == mul'(b, c) {
    use nat_mul_eq;
    use eq_refl;
    use triv;

    x : a == b;

    let y = triv(eq_refl) : c == c;
    let r = nat_mul_eq(x, y) : mul'(a, c) == mul'(b, c);
    return r;
}

fn nat_mul_eq_right : (a == b) -> mul'(c, a) == mul'(c, b) {
    use nat_mul_eq;
    use eq_refl;
    use triv;

    x : a == b;

    let y = triv(eq_refl) : c == c;
    let r = nat_mul_eq(y, x) : mul'(c, a) == mul'(c, b);
    return r;
}
